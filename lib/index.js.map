{
  "version": 3,
  "sources": ["../src/Atoms.ts", "../src/NoiseKit.ts", "../src/RTKit.ts", "../src/renderTargetUtils.ts", "../test/utils/geometry.ts", "../test/utils/math.ts", "../src/RTDoubleBufferKit.ts", "../src/MotionKit.ts", "../src/VelocityFieldKit.ts", "../src/DensityFieldKit.ts", "../src/index.ts"],
  "sourcesContent": ["import {\n  AdditiveBlending,\n  BufferAttribute,\n  BufferGeometry,\n  Points,\n  ShaderMaterial,\n  Sphere,\n  WebGLRenderer\n} from 'three'\n\nimport fragmentShader from './point.frag.glsl'\nimport vertexShader from './point.vert.glsl'\nimport MotionKit from './MotionKit'\nimport VelocityFieldKit from './VelocityFieldKit'\nimport DensityFieldKit from './DensityFieldKit'\n\nexport default class Atoms {\n  visuals: Points\n  motionKit: MotionKit\n  velocityKit: VelocityFieldKit\n  densityKit: DensityFieldKit\n  constructor(edgeSize = 256) {\n    const geo = new BufferGeometry()\n    const total = edgeSize * edgeSize\n    const bufferArr = new Float32Array(total * 3)\n    for (let iy = 0; iy < edgeSize; iy++) {\n      for (let ix = 0; ix < edgeSize; ix++) {\n        const i3 = (ix + iy * edgeSize) * 3\n        bufferArr[i3] = (ix + 0.5) / edgeSize\n        bufferArr[i3 + 1] = (iy + 0.5) / edgeSize\n        bufferArr[i3 + 2] = (i3 * 0.001) % 1\n      }\n    }\n    geo.setAttribute('position', new BufferAttribute(bufferArr, 3))\n    geo.boundingSphere = new Sphere(undefined, 1)\n\n    const motionKit = new MotionKit(edgeSize, geo)\n    const velocityKit = new VelocityFieldKit(\n      64,\n      geo,\n      motionKit.outputTextureUniform\n    )\n    motionKit.linkInput('uVelocitiesTexture', velocityKit.outputTextureUniform)\n\n    const densityKit = new DensityFieldKit(\n      64,\n      geo,\n      motionKit.outputTextureUniform\n    )\n    motionKit.linkInput('uDensitiesTexture', densityKit.outputTextureUniform)\n\n    const pointsMat = new ShaderMaterial({\n      fragmentShader,\n      vertexShader,\n      uniforms: {\n        uMap: motionKit.outputTextureUniform\n      },\n      blending: AdditiveBlending,\n      depthTest: false\n    })\n    const visuals = new Points(geo, pointsMat)\n\n    // visuals.add(velocityKit.getTestPlane())\n    // visuals.add(densityKit.getTestPlane())\n\n    this.motionKit = motionKit\n    this.velocityKit = velocityKit\n    this.densityKit = densityKit\n    this.visuals = visuals\n  }\n  update(renderer: WebGLRenderer, dt: number) {\n    this.motionKit.render(renderer, dt)\n    this.velocityKit.render(renderer, dt)\n    this.densityKit.render(renderer, dt)\n    this.visuals.rotation.y += dt * 0.2\n    //\n  }\n}\n", "import { Uniform, WebGLRenderer } from 'three'\n\nimport fragmentShader from './noise.frag.glsl'\nimport vertexShader from './fullclip.vert.glsl'\nimport RTKit from './RTKit'\nexport default class NoiseKit extends RTKit {\n  dirty = true\n  _phaseUniform: Uniform\n  constructor(edgeSize: number) {\n    const phaseUniform = new Uniform(0)\n    const opacityUniform = new Uniform(1)\n    const uniforms = { uPhase: phaseUniform, uOpacity: opacityUniform }\n    super(edgeSize, vertexShader, fragmentShader, uniforms)\n\n    this._phaseUniform = phaseUniform\n  }\n  public get phase() {\n    return this._phaseUniform.value\n  }\n  public set phase(value: number) {\n    this._phaseUniform.value = value\n    this.dirty = true\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    this.phase += dt * 0.1\n    if (this.dirty) {\n      this.dirty = false\n      renderer.setRenderTarget(this.rt)\n      renderer.render(this.scene, this.camera)\n      renderer.setRenderTarget(null)\n    }\n  }\n}\n", "import {\n  AdditiveBlending,\n  BufferGeometry,\n  IUniform,\n  Mesh,\n  OrthographicCamera,\n  Scene,\n  ShaderMaterial,\n  Uniform,\n  WebGLRenderTarget\n} from 'three'\n\nimport basicFragmentShader from './map.frag.glsl'\nimport basicVertexShader from './fullclip.vert.glsl'\nimport { getBasicRenderTarget } from './renderTargetUtils'\nimport { getSharedRectangleGeometry } from '../test/utils/geometry'\n\nexport default class RTKit {\n  outputTextureUniform: Uniform\n  plane: Mesh<BufferGeometry, ShaderMaterial>\n  rt: WebGLRenderTarget\n  outputRt: WebGLRenderTarget\n  getTestPlane() {\n    return new Mesh(\n      getSharedRectangleGeometry(),\n      new ShaderMaterial({\n        vertexShader: basicVertexShader,\n        fragmentShader: basicFragmentShader,\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        uniforms: { uMap: this.outputTextureUniform }\n      })\n    )\n  }\n\n  scene: Scene\n  camera: OrthographicCamera\n  constructor(\n    public edgeSize: number,\n    vertexShader: string,\n    fragmentShader: string,\n    protected _uniforms: {\n      [uniform: string]: IUniform<any>\n    }\n  ) {\n    const rt = getBasicRenderTarget(edgeSize)\n    this.outputTextureUniform = new Uniform(rt.texture)\n\n    const scene = new Scene()\n\n    const plane = new Mesh(\n      getSharedRectangleGeometry(),\n      new ShaderMaterial({\n        vertexShader,\n        fragmentShader,\n        uniforms: this._uniforms,\n        depthTest: false,\n        depthWrite: false\n      })\n    )\n    scene.add(plane)\n    const camera = new OrthographicCamera(-1, 1, 1, -1, -1, 1)\n    scene.add(camera)\n\n    this.plane = plane\n    this.scene = scene\n    this.camera = camera\n    this.rt = rt\n    this.outputRt = rt\n  }\n}\n", "import {\n  FloatType,\n  LinearEncoding,\n  NearestFilter,\n  RGBAFormat,\n  WebGLRenderTarget\n} from 'three'\n\nexport function getBasicRenderTarget(edgeSize: number) {\n  return new WebGLRenderTarget(edgeSize, edgeSize, {\n    format: RGBAFormat,\n    type: FloatType,\n    magFilter: NearestFilter,\n    minFilter: NearestFilter,\n    depthBuffer: false,\n    encoding: LinearEncoding\n  })\n}\n", "import {\n  BufferGeometry,\n  PlaneGeometry,\n  SphereBufferGeometry,\n  Vector3\n} from 'three'\n\nimport { inferDirection } from './math'\n\nexport function getChamferedBoxGeometry(\n  width: number,\n  height: number,\n  depth: number,\n  chamfer = 0.005\n) {\n  const geo = new SphereBufferGeometry(0.02, 8, 5, Math.PI * 0.125)\n  const posArr = geo.attributes.position.array as number[]\n  const normArr = geo.attributes.normal.array as number[]\n  const tempVec = new Vector3()\n  const tempPos = new Vector3()\n  const halfWidth = width * 0.5 - chamfer\n  const halfHeight = height * 0.5 - chamfer\n  const halfDepth = depth * 0.5 - chamfer\n  for (let i3 = 0; i3 < normArr.length; i3 += 3) {\n    tempVec.fromArray(normArr, i3)\n    tempPos.fromArray(posArr, i3)\n    tempVec.round()\n    if (tempVec.y === 1) {\n      tempVec.set(0, 1, 0)\n    }\n    if (tempVec.y === -1) {\n      tempVec.set(0, -1, 0)\n    }\n    tempVec.toArray(normArr, i3)\n    tempVec.multiplyScalar(chamfer)\n    tempVec.x += halfWidth * inferDirection(tempPos.x)\n    tempVec.y += halfHeight * inferDirection(tempPos.y)\n    tempVec.z += halfDepth * inferDirection(tempPos.z)\n    tempVec.toArray(posArr, i3)\n  }\n  return geo\n}\n\nconst __cachedChamferedBoxGeometry = new Map<string, SphereBufferGeometry>()\nexport function getCachedChamferedBoxGeometry(\n  width: number,\n  height: number,\n  depth: number,\n  chamfer = 0.005\n) {\n  const key = `${width};${height};${depth};${chamfer};`\n  if (!__cachedChamferedBoxGeometry.has(key)) {\n    __cachedChamferedBoxGeometry.set(\n      key,\n      getChamferedBoxGeometry(width, height, depth, chamfer)\n    )\n  }\n  return __cachedChamferedBoxGeometry.get(key)!\n}\n\nlet __sharedRectangleGeometry: BufferGeometry | undefined\nexport function getSharedRectangleGeometry() {\n  if (!__sharedRectangleGeometry) {\n    __sharedRectangleGeometry = new PlaneGeometry(2, 2)\n  }\n  return __sharedRectangleGeometry!\n}\n", "import { Camera, Plane, Ray, Vector3 } from 'three'\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, val))\n}\n\nexport function mod(val: number, freq: number) {\n  return ((val % freq) + freq) % freq\n}\n\nexport function wrap(val: number, min: number, max: number) {\n  const range = max - min\n  return ((((val - min) % range) + range) % range) + min\n}\n\nexport function absFloor(val: number) {\n  return Math.floor(Math.abs(val)) * (val < 0 ? -1 : 1)\n}\n\nconst tiny = 0.00001\nexport function closeEnough(val: number, val2: number) {\n  return Math.abs(val - val2) < tiny\n}\n\nexport const TWO_PI = 2 * Math.PI\n\nexport const RADIANS_TO_DEGREES = 180 / Math.PI\n\nexport const DEGREES_TO_RADIANS = Math.PI / 180\n\nexport function radiansToDegrees(radians: number) {\n  return radians * RADIANS_TO_DEGREES\n}\n\nexport function degreesToRadians(degrees: number) {\n  return degrees * DEGREES_TO_RADIANS\n}\n\nconst ray: Ray = new Ray()\nconst flatPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst anyPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst intersection: Vector3 = new Vector3()\n\n// const __cameraPosition = new Vector3()\n\nexport function get2DPositionOnPlane(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  plane: Plane\n) {\n  // __cameraPosition.set(0, 0, 0)\n  // camera.localToWorld(__cameraPosition)\n  ray.origin.copy(cameraWorldPos)\n  ray.direction.set(x, y, 0.5).unproject(camera).sub(cameraWorldPos).normalize()\n\n  ray.intersectPlane(plane, intersection)\n  return intersection\n}\nexport function get2DPositionAtDepth(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  atDepth = 0\n) {\n  flatPlane.constant = atDepth\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, flatPlane)\n}\nexport function get2DPositionOnPlaneHelper(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  coPlanarPoint: Vector3,\n  normal: Vector3\n) {\n  anyPlane.setFromNormalAndCoplanarPoint(normal, coPlanarPoint)\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, anyPlane)\n}\n\nexport function lerp(a: number, b: number, dt: number) {\n  const out = a + dt * (b - a)\n  return Math.abs(b - out) > 0.00001 ? out : b\n}\n\nexport function unlerp(min: number, max: number, value: number) {\n  return (value - min) / (max - min)\n}\n\nexport function unlerpClamped(min: number, max: number, value: number) {\n  return clamp(unlerp(min, max, value), 0, 1)\n}\n\nexport function degreesDifference(A: number, B: number) {\n  return ((((A - B) % 360) + 540) % 360) - 180\n}\n\nconst tau = Math.PI * 2\nconst tauAndHalf = Math.PI * 3\nexport function radiansDifference(a: number, b: number) {\n  return ((((a - b) % tau) + tauAndHalf) % tau) - Math.PI\n}\n\nexport function rand(min = 0, max = 1) {\n  return Math.random() * (max - min) + min\n}\n\nexport function rand2(scale = 1, offset = 0) {\n  return (Math.random() * 2 - 1) * scale + offset\n}\n\nexport function nextHighestPowerOfTwo(val: number) {\n  return Math.pow(Math.ceil(Math.sqrt(val)), 2)\n}\n\nexport function inferDirection(val: number, tolerance = 0.00001) {\n  if (val < -tolerance) {\n    return -1\n  } else if (val > tolerance) {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nexport function sqr(v: number) {\n  return v * v\n}\n\nexport function pixelLengthOnScreen(a: Vector3, b: Vector3, camera: Camera) {\n  a.project(camera)\n  b.project(camera)\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nconst phi = (Math.sqrt(5) + 1) * 0.5 - 1\nconst ga = phi * Math.PI * 2\nexport function pointOnSphereFibonacci(\n  index: number,\n  total: number\n): [number, number] {\n  //[long, lat];\n  return [ga * index, Math.asin(-1 + (2 * index) / total)]\n}\n\nexport function longLatToXYZ(\n  longLat: [number, number],\n  radius: number\n): [number, number, number] {\n  const long = longLat[0]\n  const lat = longLat[1]\n  return [\n    Math.cos(lat) * Math.cos(long) * radius,\n    Math.sin(lat) * radius,\n    Math.cos(lat) * Math.sin(long) * radius\n  ]\n}\n\nexport function powerOfTwo(x: number) {\n  return Math.log2(x) % 1 === 0\n}\n\nexport function assertPowerOfTwo(x: number) {\n  if (!powerOfTwo(x)) {\n    throw new Error(`${x} is not a power of two`)\n  }\n}\n", "import { IUniform, Uniform, WebGLRenderTarget } from 'three'\n\nimport RTKit from './RTKit'\n\nexport default class RTDoubleBufferKit extends RTKit {\n  inputTextureUniform: Uniform\n  rt2: WebGLRenderTarget\n\n  constructor(\n    rtKit: RTKit,\n    vertexShader: string,\n    fragmentShader: string,\n    uniforms: {\n      [uniform: string]: IUniform<any>\n    }\n  ) {\n    super(rtKit.edgeSize, vertexShader, fragmentShader, uniforms)\n    this.inputTextureUniform = new Uniform(rtKit.outputTextureUniform.value)\n    this.rt2 = rtKit.rt\n  }\n\n  linkInput(name: string, uniform: Uniform) {\n    this.plane.material.uniforms[name] = uniform\n  }\n  swap() {\n    this.outputRt = this.outputRt === this.rt ? this.rt2 : this.rt\n    this.inputTextureUniform.value = (\n      this.outputRt === this.rt ? this.rt2 : this.rt\n    ).texture\n    this.outputTextureUniform.value = this.outputRt.texture\n  }\n}\n", "import {\n  BufferGeometry,\n  Uniform,\n  WebGLRenderer,\n  WebGLRenderTarget\n} from 'three'\n\nimport fragmentShader from './motion.frag.glsl'\nimport vertexShader from './fullclip.vert.glsl'\nimport NoiseKit from './NoiseKit'\nimport RTDoubleBufferKit from './RTDoubleBufferKit'\nexport default class MotionKit extends RTDoubleBufferKit {\n  private _initPositionsNoiseKit: NoiseKit\n  initd = false\n  constructor(edgeSize: number, pointGeo: BufferGeometry) {\n    const initPositionNoiseKit = new NoiseKit(edgeSize)\n    super(initPositionNoiseKit, vertexShader, fragmentShader, {})\n    this.linkInput('uPositionsTexture', this.inputTextureUniform)\n    this._initPositionsNoiseKit = initPositionNoiseKit\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    if (!this.initd) {\n      this.initd = true\n      this.swap()\n      this._initPositionsNoiseKit.render(renderer, dt)\n    }\n    this.swap()\n    renderer.setRenderTarget(this.outputRt)\n    renderer.render(this.scene, this.camera)\n    renderer.setRenderTarget(null)\n  }\n}\n", "import {\n  AdditiveBlending,\n  BufferGeometry,\n  Mesh,\n  Points,\n  ShaderMaterial,\n  Uniform,\n  WebGLRenderer,\n  WebGLRenderTarget\n} from 'three'\n\nimport fragmentShader from './velocityField.frag.glsl'\nimport vertexShader from './velocityField.vert.glsl'\nimport fadeFragmentShader from './fade.frag.glsl'\nimport fullClipVertexShader from './fullclip.vert.glsl'\nimport noiseFragmentShader from './noise.frag.glsl'\nimport NoiseKit from './NoiseKit'\nimport RTDoubleBufferKit from './RTDoubleBufferKit'\nimport { getSharedRectangleGeometry } from '../test/utils/geometry'\nexport default class VelocityFieldKit extends RTDoubleBufferKit {\n  private _initVelocitiesNoiseKit: NoiseKit\n  initd = false\n  constructor(\n    edgeSize3d: number,\n    pointGeo: BufferGeometry,\n    positionsTextureUniform: Uniform\n  ) {\n    const edgeSize2d = Math.sqrt(Math.pow(edgeSize3d, 3))\n    const initPositionNoiseKit = new NoiseKit(edgeSize2d)\n    super(initPositionNoiseKit, fullClipVertexShader, fadeFragmentShader, {})\n    this.linkInput('uFieldVelocitiesTexture', this.inputTextureUniform)\n    this._initVelocitiesNoiseKit = initPositionNoiseKit\n\n    const points = new Points(\n      pointGeo,\n      new ShaderMaterial({\n        vertexShader,\n        fragmentShader,\n        uniforms: {\n          uPositionsTexture: positionsTextureUniform,\n          uVelocitiesTexture: this.inputTextureUniform\n        },\n        depthTest: false,\n        depthWrite: false,\n        transparent: true,\n        blending: AdditiveBlending\n      })\n    )\n    const phaseUniform = new Uniform(0)\n    const opacityUniform = new Uniform(0.015)\n    const uniforms = { uPhase: phaseUniform, uOpacity:opacityUniform }\n    const plane2 = new Mesh(\n      getSharedRectangleGeometry(),\n      new ShaderMaterial({\n        vertexShader:fullClipVertexShader,\n        fragmentShader:noiseFragmentShader,\n        uniforms,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true,\n        blending: AdditiveBlending\n      })\n    )\n    this.scene.add(plane2)\n    this.scene.add(points)\n    // this.plane.material.visible = false\n    // plane2.material.visible = false\n    this.plane.renderOrder = -2\n    plane2.renderOrder = -1\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    if (!this.initd) {\n      this.initd = true\n      this.swap()\n      this._initVelocitiesNoiseKit.render(renderer, dt)\n    }\n    this.swap()\n    renderer.setRenderTarget(this.outputRt)\n    renderer.render(this.scene, this.camera)\n    renderer.setRenderTarget(null)\n  }\n}\n", "import {\n  AdditiveBlending,\n  BufferGeometry,\n  Color,\n  Points,\n  ShaderMaterial,\n  Uniform,\n  WebGLRenderer\n} from 'three'\n\nimport fragmentShader2 from './densityField.frag.glsl'\nimport vertexShader2 from './densityField.vert.glsl'\nimport fadeFragmentShader from './fade.frag.glsl'\nimport fadeVertexShader from './fullclip.vert.glsl'\nimport RTKit from './RTKit'\n\nconst COLOR_BLACK = new Color(0, 0, 0)\n\nexport default class DensityFieldKit extends RTKit {\n  constructor(\n    edgeSize3d: number,\n    pointGeo: BufferGeometry,\n    positionsTextureUniform: Uniform\n  ) {\n    const edgeSize2d = Math.sqrt(Math.pow(edgeSize3d, 3))\n    super(edgeSize2d, fadeVertexShader, fadeFragmentShader, {})\n\n    const points = new Points(\n      pointGeo,\n      new ShaderMaterial({\n        vertexShader: vertexShader2,\n        fragmentShader: fragmentShader2,\n        uniforms: {\n          uPositionsTexture: positionsTextureUniform\n        },\n        depthTest: false,\n        depthWrite: false,\n        transparent: true,\n        blending: AdditiveBlending\n      })\n    )\n    this.scene.add(points)\n    this.plane.material.visible = false\n    this.plane.renderOrder = -1\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    renderer.setRenderTarget(this.outputRt)\n    renderer.setClearColor(COLOR_BLACK, 1)\n    renderer.clearColor()\n    renderer.render(this.scene, this.camera)\n    renderer.setRenderTarget(null)\n  }\n}\n", "import Atoms from './Atoms'\n\nexport default {\n  Atoms\n}\n"],
  "mappings": "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",
  "names": []
}
