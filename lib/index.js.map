{
  "version": 3,
  "sources": ["../src/Atoms.ts", "../src/NoiseKit.ts", "../src/index.ts"],
  "sourcesContent": ["import {\n  AdditiveBlending,\n  BufferAttribute,\n  BufferGeometry,\n  Points,\n  ShaderMaterial,\n  Sphere,\n  Uniform,\n  WebGLRenderer\n} from 'three'\n\nimport fragmentShader from './point.frag.glsl'\nimport vertexShader from './point.vert.glsl'\nimport NoiseKit from './NoiseKit'\n\nexport default class Atoms {\n  visuals: Points\n  noiseKit: NoiseKit\n  constructor(edgeSize = 256) {\n    const geo = new BufferGeometry()\n    const total = edgeSize * edgeSize\n    const bufferArr = new Float32Array(total * 3)\n    for (let iy = 0; iy < edgeSize; iy++) {\n      for (let ix = 0; ix < edgeSize; ix++) {\n        const i3 = (ix + iy * edgeSize) * 3\n        bufferArr[i3] = (ix + 0.5) / edgeSize\n        bufferArr[i3 + 1] = (iy + 0.5) / edgeSize\n        bufferArr[i3 + 2] = (i3 * 0.001) % 1\n      }\n    }\n    geo.setAttribute('position', new BufferAttribute(bufferArr, 3))\n    geo.boundingSphere = new Sphere(undefined, 1)\n\n    const noiseKit = new NoiseKit(edgeSize)\n\n    const mat2 = new ShaderMaterial({\n      fragmentShader,\n      vertexShader,\n      uniforms: {\n        uMap: new Uniform(noiseKit.rt.texture)\n      },\n      blending: AdditiveBlending,\n      depthTest: false\n    })\n    const visuals = new Points(geo, mat2)\n\n    // visuals.add(noiseKit.getTestPlane())\n\n    this.noiseKit = noiseKit\n    this.visuals = visuals\n  }\n  update(renderer: WebGLRenderer, dt: number) {\n    this.noiseKit.render(renderer, dt)\n    //\n  }\n}\n", "import {\n  AdditiveBlending,\n  FloatType,\n  Mesh,\n  NearestFilter,\n  OrthographicCamera,\n  PlaneGeometry,\n  RGBFormat,\n  Scene,\n  ShaderMaterial,\n  Uniform,\n  WebGLRenderer,\n  WebGLRenderTarget\n} from 'three'\n\nimport fragmentShader from './noise.frag.glsl'\nimport vertexShader from './fullclip.vert.glsl'\nexport default class NoiseKit {\n  getTestPlane() {\n    return new Mesh(\n      new PlaneGeometry(2, 2),\n      new ShaderMaterial({\n        fragmentShader,\n        vertexShader,\n        uniforms: { uPhase: this._phaseUniform },\n        blending: AdditiveBlending,\n        depthTest: false\n      })\n    )\n  }\n  rt: WebGLRenderTarget\n  scene: Scene\n  dirty = true\n  camera: OrthographicCamera\n  _phaseUniform: Uniform\n  constructor(edgeSize: number) {\n    const rt = new WebGLRenderTarget(edgeSize, edgeSize, {\n      format: RGBFormat,\n      type: FloatType,\n      magFilter: NearestFilter,\n      minFilter: NearestFilter,\n      depthBuffer: false\n    })\n    const scene = new Scene()\n\n    const phaseUniform = new Uniform(0)\n    const p = new Mesh(\n      new PlaneGeometry(2, 2),\n      new ShaderMaterial({\n        fragmentShader,\n        vertexShader,\n        uniforms: { uPhase: phaseUniform }\n      })\n    )\n    scene.add(p)\n    const camera = new OrthographicCamera(-1, 1, 1, -1, -1, 1)\n    scene.add(camera)\n\n    this.rt = rt\n    this.scene = scene\n    this.camera = camera\n    this._phaseUniform = phaseUniform\n  }\n  public get phase() {\n    return this._phaseUniform.value\n  }\n  public set phase(value: number) {\n    this._phaseUniform.value = value\n    this.dirty = true\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    this.phase += dt * 0.001\n    if (this.dirty) {\n      this.dirty = false\n      renderer.setRenderTarget(this.rt)\n      renderer.render(this.scene, this.camera)\n      renderer.setRenderTarget(null)\n    }\n  }\n}\n", "import Atoms from './Atoms'\n\nexport default {\n  Atoms\n}\n"],
  "mappings": "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",
  "names": []
}
